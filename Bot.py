
import os
import random
import datetime
import asyncio
import aiohttp
import pytz
import signal
import sys
from twitchio.ext import commands

# Configuraci√≥n para Railway
def signal_handler(sig, frame):
    print('Bot detenido graciosamente')
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)


class ROJOBOT(commands.Bot):
    
    def __init__(self):
        # Configuraci√≥n del bot
        super().__init__(
            token='jnr18ofr2r8e7br0krnkea9mrb4dpn',  # Token OAuth configurado
            prefix='!',  # Prefijo para los comandos
            initial_channels=['elrojotw']  # Tu canal
        )
        
        # Variables para el bot
        self.start_time = datetime.datetime.now()
        self.puntos_usuarios = {}  # Sistema de puntos simple
        self.usuarios_activos = []  # Lista de usuarios activos en el chat
        self.colombia_tz = pytz.timezone('America/Bogota')
        
        # Sistema de conversaci√≥n simple (sin IA)
        self.conversaciones_activas = {}  # {usuario: {'ultimo_mensaje': datetime, 'contexto': str}}
        self.tiempo_timeout = 120  # 2 minutos en segundos
        
        # Configuraci√≥n para clips autom√°ticos
        self.clips_automaticos = True
        self.palabras_clip = [
            'poggers', 'pog', 'increible', 'incre√≠ble', 'genial', 'brutal', 
            'savage', 'clip', 'clipea', 'momento', '√©pico', 'epico', 'wow',
            'omg', 'wtf', 'lol', 'kekw', 'insane', 'loco', 'impresionante'
        ]
        self.ultimo_clip = None
        self.cooldown_clip = 60  # 1 minuto entre clips autom√°ticos
        
        # Contadores para clips autom√°ticos
        self.contador_mensajes_clip = 0
        self.limite_mensajes_clip = 15  # Crear clip cada 15 mensajes con palabras clave
        
        # API de The Fyre Wire para clips
        self.fyre_api_url = "https://api.thefyrewire.com/twitch/clips"
        
        # Configuraci√≥n de Twitch (para informaci√≥n adicional)
        self.canal_twitch = 'elrojotw'
    
    async def event_ready(self):
        """Se ejecuta cuando el bot est√° listo"""
        print(f'ROJOBOT conectado como {self.nick}')
        print(f'Conectado al canal: {self.canal_twitch}')
        print('‚úì Sistema de clips autom√°ticos activado')
        print('‚úì Comando !clip manual disponible')
        print('‚úì Detecci√≥n de palabras clave para clips autom√°ticos')
        
        # Iniciar tarea de limpieza de conversaciones
        self.loop.create_task(self.limpiar_conversaciones_inactivas())
    
    async def event_message(self, message):
        """Se ejecuta con cada mensaje en el chat"""
        # Ignorar mensajes del propio bot
        if message.echo:
            return
        
        # Actualizar lista de usuarios activos
        if message.author.name not in self.usuarios_activos:
            self.usuarios_activos.append(message.author.name)
        
        # Verificar si el usuario est√° en una conversaci√≥n activa
        if message.author.name in self.conversaciones_activas:
            if not message.content.startswith('!'):
                await self.continuar_conversacion(message)
                return
        
        # Detectar palabras clave para clips autom√°ticos
        await self.detectar_palabras_clip(message)
        
        # Procesar comandos
        await self.handle_commands(message)
        
        # Respuestas autom√°ticas
        mensaje_lower = message.content.lower()
        
        # Saludar cuando alguien dice hola
        if mensaje_lower.strip() == 'hola' and message.author.name not in self.conversaciones_activas:
            await message.channel.send(f'¬°Hola @{message.author.name}! ¬°Bienvenido al stream! üëãüî¥')
        
        # Saludar cuando mencionan al bot
        if 'rojobot' in mensaje_lower and 'hola' in mensaje_lower:
            await message.channel.send(f'¬°Hola @{message.author.name}! ¬øC√≥mo est√°s? ü§ñ')
        
        # Sistema de puntos
        if message.author.name not in self.puntos_usuarios:
            self.puntos_usuarios[message.author.name] = 0
        self.puntos_usuarios[message.author.name] += 1
    
    async def detectar_palabras_clip(self, message):
        """Detecta palabras clave en el chat para crear clips autom√°ticos"""
        if not self.clips_automaticos:
            return
        
        mensaje_lower = message.content.lower()
        
        # Verificar si contiene palabras clave
        for palabra in self.palabras_clip:
            if palabra in mensaje_lower:
                self.contador_mensajes_clip += 1
                
                # Crear clip autom√°tico si se alcanza el l√≠mite
                if self.contador_mensajes_clip >= self.limite_mensajes_clip:
                    await self.crear_clip_automatico(message, palabra)
                    self.contador_mensajes_clip = 0
                break
    
    async def crear_clip_automatico(self, message, palabra_clave):
        """Crea un clip autom√°tico usando la API de The Fyre Wire"""
        # Verificar cooldown
        if self.ultimo_clip:
            tiempo_desde_ultimo = (datetime.datetime.now() - self.ultimo_clip).total_seconds()
            if tiempo_desde_ultimo < self.cooldown_clip:
                return
        
        try:
            # Crear clip usando The Fyre Wire API
            clip_data = await self.crear_clip_fyre_wire(
                titulo=f"Momento √©pico por '{palabra_clave}' - {message.author.name}",
                auto=True
            )
            
            if clip_data:
                self.ultimo_clip = datetime.datetime.now()
                await message.channel.send(
                    f'üìπ ¬°Clip autom√°tico creado! Palabra clave: "{palabra_clave}" '
                    f'detectada por @{message.author.name} üé¨'
                )
        except Exception as e:
            print(f"Error al crear clip autom√°tico: {e}")
    
    async def crear_clip_fyre_wire(self, titulo="Clip de ElRojoTW", auto=False):
        """Crea un clip usando The Fyre Wire API"""
        try:
            # Par√°metros para la API
            params = {
                'channel': self.canal_twitch,
                'title': titulo[:100],  # Limitar t√≠tulo a 100 caracteres
                'duration': 30,  # 30 segundos por defecto
                'delay': 0,  # Sin delay
                'has_delay': 'false'
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(self.fyre_api_url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data
                    else:
                        print(f"Error en API Fyre Wire: {response.status}")
                        return None
                        
        except Exception as e:
            print(f"Error al conectar con Fyre Wire API: {e}")
            return None
    
    async def continuar_conversacion(self, message):
        """Contin√∫a una conversaci√≥n simple sin IA"""
        usuario = message.author.name
        
        # Actualizar timestamp
        self.conversaciones_activas[usuario]['ultimo_mensaje'] = datetime.datetime.now()
        
        # Obtener contexto de la conversaci√≥n
        contexto = self.conversaciones_activas[usuario].get('contexto', '')
        
        # Generar respuesta simple
        respuesta = self.generar_respuesta_simple(usuario, message.content, contexto)
        
        # Actualizar contexto
        self.conversaciones_activas[usuario]['contexto'] = contexto + f" Usuario: {message.content}"
        
        # Enviar respuesta
        await message.channel.send(f'@{usuario} {respuesta}')
    
    def generar_respuesta_simple(self, usuario, mensaje, contexto=""):
        """Genera respuestas simples sin IA"""
        mensaje_lower = mensaje.lower()
        
        # Respuestas para despedidas
        if any(despedida in mensaje_lower for despedida in ['adi√≥s', 'adios', 'chao', 'bye', 'hasta luego', 'me voy']):
            self.conversaciones_activas.pop(usuario, None)
            return "¬°Nos vemos! Gracias por la charla üëã"
        
        # Respuestas para saludos
        if any(saludo in mensaje_lower for saludo in ['hola', 'hi', 'hey', 'buenas', 'saludos', 'qu√© tal']):
            return random.choice([
                "¬°Hey! ¬øQu√© tal va tu d√≠a? üòä",
                "¬°Hola! ¬øListo para disfrutar el stream? üéÆ",
                "¬°Buenas! Me alegra verte por aqu√≠ üî¥",
                "¬°Qu√© onda! ¬øC√≥mo va todo? üéØ",
                "¬°Saludos! El stream est√° genial hoy üî•"
            ])
        
        # Respuestas para preguntas sobre juegos
        if any(palabra in mensaje_lower for palabra in ['juego', 'jugar', 'gaming', 'game', 'videojuego']):
            return random.choice([
                "¬°Los juegos son mi pasi√≥n! ¬øCu√°l es tu favorito? üéÆ",
                "¬°ElRojo siempre elige los mejores juegos! üïπÔ∏è",
                "Gaming es vida! ¬øQu√© g√©nero prefieres? üéØ",
                "¬°Nada como un buen gaming session! üî•"
            ])
        
        # Respuestas sobre ElRojo
        if any(palabra in mensaje_lower for palabra in ['rojo', 'elrojo', 'streamer', 'canal']):
            return random.choice([
                "¬°ElRojo es el mejor! Su energ√≠a es √∫nica üî¥",
                "¬°Este stream est√° que arde gracias a ElRojo! üî•",
                "¬°ElRojo siempre nos sorprende! ‚ù§Ô∏è",
                "¬°Nadie como ElRojo para animar el chat! üéâ"
            ])
        
        # Respuestas sobre el stream
        if any(palabra in mensaje_lower for palabra in ['stream', 'directo', 'live', 'transmisi√≥n']):
            return random.choice([
                "¬°El stream de hoy est√° √©pico! üé¨",
                "¬°Me encanta la vibra del stream! üî¥",
                "¬°Qu√© buen stream estamos teniendo! üíØ",
                "¬°Este stream est√° on fire! üî•"
            ])
        
        # Respuestas para emociones positivas
        if any(palabra in mensaje_lower for palabra in ['genial', 'incre√≠ble', 'brutal', '√©pico', 'wow', 'amazing']):
            return random.choice([
                "¬°Exactamente! ¬°Esa es la actitud! üî•",
                "¬°Me contagias tu energ√≠a! üéâ",
                "¬°Eso es lo que me gusta escuchar! üíØ",
                "¬°Qu√© buena vibra tienes! ‚ú®"
            ])
        
        # Respuestas para preguntas
        if any(pregunta in mensaje_lower for pregunta in ['?', 'c√≥mo', 'como', 'qu√©', 'que', 'cu√°l', 'cual', 'd√≥nde', 'donde']):
            return random.choice([
                "¬°Buena pregunta! ¬øQu√© piensas t√∫? ü§î",
                "¬°Interesante! Dime m√°s sobre eso üí≠",
                "¬°Uff, me hiciste pensar! üß†",
                "¬°Esa s√≠ que es una buena pregunta! üéØ"
            ])
        
        # Respuestas sobre clips
        if any(palabra in mensaje_lower for palabra in ['clip', 'clipea', 'momento', 'guarda']):
            return random.choice([
                "¬°S√≠! ¬°Ese momento merece un clip! üìπ",
                "¬°Usa !clip para crear uno! üé¨",
                "¬°Los clips autom√°ticos est√°n activados! üî¥",
                "¬°Qu√© buen ojo para los momentos √©picos! üéØ"
            ])
        
        # Respuestas gen√©ricas
        return random.choice([
            "¬°Qu√© interesante! Cu√©ntame m√°s ü§î",
            "¬°No hab√≠a pensado en eso! üí≠",
            "¬°Me encanta hablar contigo! üòÑ",
            "¬°Eso est√° genial! ¬øY qu√© m√°s? üéâ",
            "¬°Wow! Sigue cont√°ndome üöÄ",
            "¬°Qu√© buena vibra tienes! ‚ú®",
            "¬°Me gusta tu estilo! üòé",
            "¬°Eres parte de la mejor comunidad! ‚ù§Ô∏è"
        ])
    
    async def limpiar_conversaciones_inactivas(self):
        """Limpia las conversaciones inactivas"""
        while True:
            await asyncio.sleep(30)  # Verificar cada 30 segundos
            
            ahora = datetime.datetime.now()
            usuarios_a_eliminar = []
            
            for usuario, datos in self.conversaciones_activas.items():
                tiempo_inactivo = (ahora - datos['ultimo_mensaje']).total_seconds()
                
                if tiempo_inactivo > self.tiempo_timeout:
                    usuarios_a_eliminar.append(usuario)
            
            # Eliminar conversaciones inactivas
            for usuario in usuarios_a_eliminar:
                self.conversaciones_activas.pop(usuario, None)
    
    # COMANDOS B√ÅSICOS
    
    @commands.command(name='hola')
    async def hola(self, ctx):
        """Saluda al usuario"""
        await ctx.send(f'¬°Hola @{ctx.author.name}! ¬°Bienvenido al stream de ElRojoTW! üëãüî¥')
    
    @commands.command(name='comandos')
    async def comandos(self, ctx):
        """Lista todos los comandos disponibles"""
        comandos_lista = '!hola, !discord, !redes, !horario, !dado, !amor, !puntos, !uptime, !clip, !followrojo, !8ball, !chat, !clipauto'
        await ctx.send(f'üìã Comandos disponibles: {comandos_lista}')
    
    @commands.command(name='discord')
    async def discord(self, ctx):
        """Muestra el link de Discord"""
        await ctx.send('üí¨ ¬°√önete a nuestro Discord! ‚Üí https://discord.gg/K4tYpsJmbk')
    
    @commands.command(name='redes')
    async def redes(self, ctx):
        """Muestra las redes sociales"""
        await ctx.send('‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨ùì¢ùì≤ùì∞ùìæùìÆùì∂ùìÆ‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨ Encu√©ntrame en estas redes sociales. https://bit.ly/3P3sPsN Instagram: https://bit.ly/3aw6NzJ Twitter: https://bit.ly/3uImE56 Facebook: https://bit.ly/3uILYrO Canal Principal: https://bit.ly/3uKe1Hf Canal Secundario: https://bit.ly/3Pm7s5z Tiktok: https://bit.ly/3yzvR0W Discord: contactoelrojoyt10@gmail.com ‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨ùì¢ùì≤ùì∞ùìæùìÆùì∂ùìÆ‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨')
    
    @commands.command(name='horario')
    async def horario(self, ctx):
        """Muestra el horario de streams"""
        ahora_colombia = datetime.datetime.now(self.colombia_tz)
        await ctx.send(f'üïê Horario de streams (Hora Colombia üá®üá¥): Lunes a Viernes 8:00 PM - 11:00 PM | S√°bados y Domingos horario especial!')
    
    # COMANDOS DE CLIPS
    
    @commands.command(name='clip')
    async def clip_manual(self, ctx, *, titulo: str = None):
        """Crea un clip manual usando The Fyre Wire API"""
        if not titulo:
            titulo = f"Clip de {ctx.author.name}"
        
        await ctx.send(f'üìπ @{ctx.author.name} est√° creando un clip... ¬°Un momento! üé¨')
        
        try:
            clip_data = await self.crear_clip_fyre_wire(titulo=titulo)
            
            if clip_data:
                await ctx.send(f'‚úÖ ¬°Clip creado exitosamente por @{ctx.author.name}! üéâ')
            else:
                await ctx.send('‚ùå No pude crear el clip. Verifica que el stream est√© activo.')
                
        except Exception as e:
            print(f"Error al crear clip manual: {e}")
            await ctx.send('‚ùå Ocurri√≥ un error al crear el clip. Intenta de nuevo.')
    
    @commands.command(name='clipauto')
    async def toggle_clips_automaticos(self, ctx):
        """Activa/desactiva los clips autom√°ticos (solo mods)"""
        if not ctx.author.is_mod and ctx.author.name.lower() != 'elrojotw':
            await ctx.send('‚ùå Solo los moderadores pueden usar este comando.')
            return
        
        self.clips_automaticos = not self.clips_automaticos
        estado = "activados" if self.clips_automaticos else "desactivados"
        emoji = "‚úÖ" if self.clips_automaticos else "‚ùå"
        
        await ctx.send(f'{emoji} Clips autom√°ticos {estado}')
    
    @commands.command(name='clipstats')
    async def clip_stats(self, ctx):
        """Muestra estad√≠sticas de los clips"""
        await ctx.send(f'üìä Clips autom√°ticos: {"‚úÖ" if self.clips_automaticos else "‚ùå"} | '
                      f'Mensajes hasta pr√≥ximo clip: {self.limite_mensajes_clip - self.contador_mensajes_clip} | '
                      f'Palabras clave detectadas: {len(self.palabras_clip)}')
    
    # COMANDO DE CHAT CONVERSACIONAL
    
    @commands.command(name='chat')
    async def chat(self, ctx, *, mensaje: str = None):
        """Inicia una conversaci√≥n simple con el bot"""
        usuario = ctx.author.name
        
        if not mensaje:
            await ctx.send(f'@{usuario} ¬°Hola! Usa !chat [tu mensaje] para comenzar a conversar conmigo. '
                          f'Despu√©s puedes escribir normalmente. La charla termina despu√©s de 2 minutos de inactividad. üí¨')
            return
        
        # Iniciar nueva conversaci√≥n
        self.conversaciones_activas[usuario] = {
            'ultimo_mensaje': datetime.datetime.now(),
            'contexto': f"Usuario: {mensaje}"
        }
        
        # Generar respuesta
        respuesta = self.generar_respuesta_simple(usuario, mensaje)
        
        # Enviar respuesta
        await ctx.send(f'@{usuario} {respuesta}')
    
    # COMANDOS DIVERTIDOS
    
    @commands.command(name='dado')
    async def dado(self, ctx):
        """Tira un dado"""
        resultado = random.randint(1, 6)
        mensajes_dado = {
            1: "¬°Uy! Sacaste un 1... La suerte no est√° de tu lado hoy, pero no te rindas! üé≤",
            2: "Un 2... Dicen que los pares traen buena energ√≠a. ¬°Sigue intentando! üé≤",
            3: "¬°Un 3! El n√∫mero de la creatividad. Algo bueno se acerca... üé≤",
            4: "¬°4! N√∫mero de estabilidad. Tu suerte est√° mejorando considerablemente üé≤",
            5: "¬°Casi perfecto! Un 5 significa que est√°s a punto de lograr algo grande üé≤",
            6: "¬°INCRE√çBLE! ¬°Sacaste un 6! ¬°Eres el rey/reina de la suerte hoy! üé≤üëë"
        }
        await ctx.send(f'@{ctx.author.name} tir√≥ el dado y sac√≥ un {resultado}! {mensajes_dado[resultado]}')
    
    @commands.command(name='amor')
    async def amor(self, ctx):
        """Calcula el porcentaje de amor con alguien random del chat"""
        if len(self.usuarios_activos) < 2:
            await ctx.send(f'üíï Necesitamos m√°s personas en el chat para calcular el amor!')
            return
        
        usuarios_disponibles = [u for u in self.usuarios_activos if u != ctx.author.name]
        usuario_random = random.choice(usuarios_disponibles)
        
        porcentaje = random.randint(0, 100)
        if porcentaje < 30:
            emoji = 'üíî'
            mensaje = 'Quiz√°s en otra vida...'
        elif porcentaje < 70:
            emoji = 'üíï'
            mensaje = '¬°Hay qu√≠mica!'
        else:
            emoji = 'üíñ'
            mensaje = '¬°Es amor verdadero!'
        
        await ctx.send(f'{emoji} @{ctx.author.name} tiene {porcentaje}% de compatibilidad amorosa con @{usuario_random}! {mensaje}')
    
    @commands.command(name='8ball')
    async def bola8(self, ctx, *, pregunta: str = None):
        """La bola m√°gica responde"""
        if not pregunta:
            await ctx.send('üé± Debes hacer una pregunta despu√©s del comando. Ejemplo: !8ball ¬øGanar√© hoy?')
            return
        
        respuestas_positivas = [
            f'üé± Las estrellas se alinean a tu favor, @{ctx.author.name}. La respuesta es S√ç.',
            f'üé± Mi visi√≥n c√≥smica me dice que definitivamente s√≠, @{ctx.author.name}.',
            f'üé± Todo apunta a que s√≠. El universo conspira a tu favor.',
            f'üé± Sin duda alguna, @{ctx.author.name}. El destino as√≠ lo ha decidido.'
        ]
        
        respuestas_negativas = [
            f'üé± Las energ√≠as no est√°n alineadas, @{ctx.author.name}. La respuesta es no.',
            f'üé± Mi sabidur√≠a ancestral dice que no es el momento.',
            f'üé± Los astros indican que no, pero no pierdas la esperanza.',
            f'üé± Lamentablemente no veo eso en tu futuro cercano.'
        ]
        
        respuestas_inciertas = [
            f'üé± Las nieblas del futuro nublan mi visi√≥n... Pregunta m√°s tarde.',
            f'üé± El destino a√∫n no est√° escrito, @{ctx.author.name}. Int√©ntalo de nuevo.',
            f'üé± Mi esfera est√° recalculando... Vuelve a preguntar en unos minutos.',
            f'üé± La respuesta est√° en movimiento. El futuro es incierto.'
        ]
        
        tipo = random.choice(['positiva', 'negativa', 'incierta'])
        if tipo == 'positiva':
            respuesta = random.choice(respuestas_positivas)
        elif tipo == 'negativa':
            respuesta = random.choice(respuestas_negativas)
        else:
            respuesta = random.choice(respuestas_inciertas)
        
        await ctx.send(respuesta)
    
    # COMANDOS DE INFORMACI√ìN
    
    @commands.command(name='puntos')
    async def puntos(self, ctx):
        """Muestra los puntos del usuario"""
        puntos = self.puntos_usuarios.get(ctx.author.name, 0)
        await ctx.send(f'üèÜ @{ctx.author.name} tiene {puntos} puntos rojos!')
    
    @commands.command(name='uptime')
    async def uptime(self, ctx):
        """Muestra cu√°nto tiempo lleva el bot activo"""
        ahora = datetime.datetime.now()
        uptime = ahora - self.start_time
        horas = int(uptime.total_seconds() // 3600)
        minutos = int((uptime.total_seconds() % 3600) // 60)
        await ctx.send(f'‚è±Ô∏è ROJOBOT lleva activo: {horas}h {minutos}m')
    
    @commands.command(name='followrojo')
    async def followrojo(self, ctx):
        """Simula informaci√≥n de seguimiento"""
        dias_siguiendo = random.randint(1, 1000)
        fecha_follow = datetime.datetime.now() - datetime.timedelta(days=dias_siguiendo)
        
        tiempo_siguiendo = datetime.datetime.now() - fecha_follow
        
        a√±os = tiempo_siguiendo.days // 365
        meses = (tiempo_siguiendo.days % 365) // 30
        dias = (tiempo_siguiendo.days % 365) % 30
        
        tiempo_str = ""
        if a√±os > 0:
            tiempo_str += f"{a√±os} a√±o{'s' if a√±os > 1 else ''}, "
        if meses > 0:
            tiempo_str += f"{meses} mes{'es' if meses > 1 else ''}, "
        if dias > 0:
            tiempo_str += f"{dias} d√≠a{'s' if dias > 1 else ''}"
        
        await ctx.send(f'‚ù§Ô∏è @{ctx.author.name} lleva siguiendo a ElRojoTW por: {tiempo_str}')
    
    # COMANDOS PARA MODERADORES
    
    @commands.command(name='so')
    async def shoutout(self, ctx, usuario: str = None):
        """Shoutout a otro streamer (solo mods)"""
        if not ctx.author.is_mod and ctx.author.name.lower() != 'elrojotw':
            return
        
        if usuario:
            usuario = usuario.replace('@', '')
            await ctx.send(f'üì¢ ¬°Vayan a seguir a @{usuario}! ‚Üí twitch.tv/{usuario}')
    
    @commands.command(name='titulo')
    async def titulo(self, ctx, *, nuevo_titulo: str = None):
        """Actualiza el t√≠tulo del stream (solo mods)"""
        if not ctx.author.is_mod and ctx.author.name.lower() != 'elrojotw':
            return
        
        if nuevo_titulo:
            await ctx.send(f'üìù T√≠tulo actualizado: {nuevo_titulo}')
    
    # EVENTOS ESPECIALES
    
    async def event_usernotice_subscription(self, metadata):
        """Se ejecuta cuando alguien se suscribe"""
        channel = self.get_channel('elrojotw')
        await channel.send(f'üéâ ¬°Gracias @{metadata.user.name} por la suscripci√≥n! ¬°Bienvenido a la familia roja! ‚ù§Ô∏è')
    
    async def event_raid(self, raid):
        """Se ejecuta cuando reciben una raid"""
        channel = self.get_channel('elrojotw')
        await channel.send(f'üö® ¬°RAID! ¬°Gracias @{raid.user.name} por la raid con {raid.viewer_count} viewers! ¬°Bienvenidos todos! üéä')
    
    async def event_join(self, channel, user):
        """Se ejecuta cuando alguien entra al chat"""
        if user.name not in self.usuarios_activos:
            self.usuarios_activos.append(user.name)
    
    async def event_part(self, user):
        """Se ejecuta cuando alguien sale del chat"""
        if user.name in self.usuarios_activos:
            self.usuarios_activos.remove(user.name)
        
        if user.name in self.conversaciones_activas:
            self.conversaciones_activas.pop(user.name, None)

# CONFIGURACI√ìN PARA EJECUTAR EL BOT
if __name__ == '__main__':
    print('=== ROJOBOT MEJORADO - SIN CHATGPT ===')
    print('‚úì ChatGPT eliminado - Conversaciones simples')
    print('‚úì Clips autom√°ticos con The Fyre Wire API')
    print('‚úì Detecci√≥n de palabras clave para clips')
    print('‚úì Comando !clip manual mejorado')
    print('‚úì Comando !clipauto para mods')
    print('‚úì Sistema de conversaci√≥n simple y eficiente')
    print('‚úì Todas las funcionalidades originales mantenidas')
    print('=====================================\n')
    
    print('üé¨ CONFIGURACI√ìN DE CLIPS:')
    print('- API: The Fyre Wire (https://thefyrewire.com)')
    print('- Clips autom√°ticos: Activados')
    print('- Palabras clave: poggers, pog, incre√≠ble, genial, brutal, etc.')
    print('- L√≠mite: 1 clip cada 1 minuto')

    bot = ROJOBOT()
    bot.run()